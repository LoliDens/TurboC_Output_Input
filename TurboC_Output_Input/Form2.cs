using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace TurboC_Output_Input
{
    public partial class Form2 : Form
    {
        string text1 = "Стандартный способ\r\nПроцедуры доступа к портам ввода/выводы находятся в /usr/include/asm/io.h.\r\nПроцедуры представляют собой встроенные (inline) макроопределения, так что вам не \r\nнужны никакие библиотеки, и достаточно просто добавить #include <asm/io.h>. Вы \r\nдолжны компилировать любые исходные тексты, использующие эти процедуры, с \r\nвключенной оптимизацией (gcc -O1 или выше), или же определить пустое #define \r\nextern перед #include <asm/io.h>. \r\nДля отладки вы можете использовать gcc -g -O (по крайней мере, с современными \r\nверсиями gcc), хотя оптимизация может привести к немного странному поведению \r\nотладчика.\r\nПеред тем, как вы получите доступ к какому-нибудь порту, вы должны дать вашей \r\nпрограмме права на это. Это выполняется, при помощи функции ioperm(from, num, \r\nturn_on) (определенной в unistd.h и находящейся в ядре), где from это первый порт, \r\nа num это количество подряд идущих портов, которым нужно дать доступ. Последний \r\nаргумент - это двоичное значение, определяющее, дать ли доступ к портам (истина (1)) \r\nили запретить его (ложь (0)). Для включения портов, идущих не подряд, вы можете \r\nвызывать ioperm() несколько раз. Вам не нужно непосредственно освобождать порты \r\nпри помощи ioperm(..., 0), т.к. это делается автоматически, когда программа \r\nзаканчивает работу.\r\nДля вызова ioperm() необходимо иметь права root; таким образом, вы должны \r\nзапускать программу от пользователя root или установить на файл флаг setuid.\r\nВыполнение setuid() для переключения на другого пользователя не отключает доступ \r\nк портам, данный ioperm(), но это происходит при fork (наследованный процесс \r\nтеряет доступ, когда как у порождающего процесса он остается).\r\nioperm() может дать доступ только к портам с 0x000 по 0x3ff; для других портов вам \r\nнужно использовать iopl().\r\nЧтобы считать байт (8 бит) из порта, вызовите функцию inb(port), возвращающую \r\nсчитанный байт. Чтобы вывести байт в порт, вызовите процедуру outb(value, \r\nport) (обратите внимание на порядок аргументов). Чтобы считать компьютерное слово \r\n(16 бит) из портов x и x+1 (по одному байту из каждого образуют слово), вызовите \r\nфункцию inw(x). Чтобы вывести слово в два порта, используйте outw(value, x). \r\nТакже замечу, что все функции, работающие с портами, требуют, как минимум, около \r\nмикросекунды для выполнения.";
        string text2 = "Альтернативный способ: /dev/port\r\nДругой путь доступа к портам ввода/вывода лежит через открытие \r\nфайла /dev/port. (символьное устройство - major 1, minor 4) на чтение и/или \r\nзапись (функции f*() из stdio.h работают через буфер, поэтому избегайте их). \r\nЗатем выполняем lseek() на необходимый байт в файле (позиция файла 0 = \r\nпорт 0x00, позиция файла 1 = порт 0x01, и т.д.), и считываем/записываем байт \r\nили слово при помощи read() или write().\r\nЕстественно, для работы программы вам нужен доступ на чтение/запись к \r\nфайлу /dev/port. Этот способ конечно медленней, чем стандартный, но не \r\nтребует ни оптимизации при компиляции, ни ioperm(). Кроме того, если вы \r\nдадите доступ соответствующим пользователю/группе к файлу /dev/port, вашей \r\nпрограмме не нужны права root --- впрочем, это не очень хорошая вещь с точки \r\nзрения безопасности, поскольку это может нарушить работу системы путем \r\nполучения прав root через доступ к диску, сетевой плате и т.д. напрямую.";

        public Form2()
        {
            InitializeComponent();
        }


        private void Form2_FormClosed(object sender, FormClosedEventArgs e)
        {
            Form1 form = new Form1();
            form.Show();
            this.Hide();
        }

        private void Form2_Load(object sender, EventArgs e)
        {
            textBox1.Multiline = true;
            textBox1.Height = 300;
            textBox1.Text = text1;
        }

    

        private void button1_Click(object sender, EventArgs e)
        {
            textBox1.Text = text1;
        }

        private void button2_Click(object sender, EventArgs e)
        {
            textBox1.Text = text2;
        }

        private void label1_Click(object sender, EventArgs e)
        {

        }
    }
}
